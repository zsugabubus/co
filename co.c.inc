#if !CO_FAST
_Thread_local Coroutine *co_self;
#endif

static void
CO_MAKE_NAME(, co_return)(void)
{
	register void *rax asm("rax");
	void *arg = rax;

	co_self->co_done = 1;

#if 0
	fprintf(stderr, "co: [%s] finished\n", co_get_name(co_self));
#endif

	(void)CO_MAKE_NAME(, co_yield)(arg);
	assert(!"Resumed terminated coroutine");
	__builtin_unreachable();
}

void
CO_MAKE_NAME(, co_create)(Coroutine *c, void *routine(Coroutine *, void *))
{
#if CO_HAVE_VALGRIND
	c->vg_stack_id = VALGRIND_STACK_REGISTER(c->stack, c->stack_sz);
#endif

#ifndef CO_NDEBUG
	c->co_fast = CO_FAST;
#endif
	c->co_done = 0;

	void *their_stack = c->co_frame;
	void *saved_stack = saved_stack;

#ifdef __x86_64__
	__asm__(
			"mov %%rsp,%[saved_stack]\n\t"

			/* Setup their stack and initial frame. */
			"mov %[their_stack],%%rsp\n\t"
# ifndef CO_NDEBUG

			/* It should be really the address of last co_resume()
			 * if we would really would like to show something. */
			/* "lea 0(%%rip),%%rax\n\t" "push %%rax\n\t" */
			"sub $0x10,%%rsp\n\t"
			/* return address */
			/* previous %bp value */
# endif
			"lea %[co_return],%%rax\n\t" "push %%rax\n\t"
			"push %[routine]\n\t"
			"push %[c]\n\t"
			"lea %[co_trampoline],%%rax\n\t" "push %%rax\n\t"

# ifndef CO_NDEBUG
			/* Set %bp to reference our dummy frame above. */
			"lea -0x10(%[their_stack]),%%rax\n\t" "push %%rax\n\t"
# endif

			/* "pushq $0x0\n\t" */

			/* Registers will receive garbage. */
			"sub %[nsaved],%%rsp\n\t"

			"mov %%rsp,%[their_stack]\n\t"

			"mov %[saved_stack],%%rsp\n\t"

			: [saved_stack] "+r"(saved_stack),
			  [their_stack] "+r"(their_stack)

			: [routine] "r"(routine),
			  [c] "r"(c),
			  [co_trampoline] "m"(co_trampoline),
			  [co_return] "m"(CO_MAKE_NAME(, co_return)),
			  [nsaved] "i"(
				0
#define xmacro(name) +sizeof(uint64_t)
				CO_CALLEE_SAVED(CO_ORDER_PUSH)
#undef xmacro
				/* %bp */
				+sizeof(uint64_t)
				/*+ sizeof(uint64_t) */ /* => !((%rsp + 8) % 16) -> MUST be popped accordingly */
			  )
			: "rax"
	);
#endif
	c->co_frame = their_stack;
}

/**
 * %bp cannot be clobbered, however we must save it.
 * We must need: naked. If compiler emits a push (O0: push %bp) it will not
 * match with our stack setup with co_create.
 *
 * However with naked no "ret" instruction is generated.
 *
 * We need "ret" to be generated by the comiler so it can be inlined.
 * (Otherwise if we specify it within the assembly we must mark function
 * noinline).
 */
__attribute__((optimize("O3"), noinline, naked, hot))
void *
CO_MAKE_NAME(co_internal_, co_switch)(Coroutine *from, Coroutine *to, void *arg)
{
#if 0
	fprintf(stderr, "co: from [%s] resume [%s] (st=%p) with %p\n", co_get_name(co_self), co_get_name(c), c->frame, arg);
#endif

#ifndef CO_NDEBUG
	from->co_fast = CO_FAST;
	assert(CO_FAST == to->co_fast);
	to->co_fast = CO_FAST;
#endif

#ifdef __x86_64__
	/* GCC generates an extra mov if  is part of the next assembly. */
	__asm__ volatile("mov %0,%%rax"::"r"(arg):"rax");

	__asm__ volatile /* %bp and %sp modified. */ (
# ifndef CO_NDEBUG
			/* Get return address. Push it back immediately so we
			 * can ignore direction of the stack. */
			"pop %%r11\n\t"
			"push %%r11\n\t"
			/* "mov (%%rsp),%%rax\n\t" */
# endif
			/* Save our registers. */
			"push %%rbp\n\t"
			/* "push %[from]\n\t" */
# define xmacro(name) "push %%"#name"\n\t"
			CO_CALLEE_SAVED(CO_ORDER_PUSH)
# undef xmacro

			"mov %%rsp,%[our_frame]\n\t"

# ifndef CO_NDEBUG
			/* Update return address and %bp. */
			"mov %[stack],%%rsp\n\t"
			"push %%r11\n\t"
			"push %%rbp\n\t"
# endif
			/* Move to their frame. */
			"mov %[frame],%%rsp\n\t"
			/* Place it before we modify %rsp or %rbp because we
			* accept memory references and we cannot mark these
			* registers clobbered. */
			/* "mov %[arg],%%rax\n\t" */

			/* Restore their registers. */
# define xmacro(name) "pop %%"#name"\n\t"
			CO_CALLEE_SAVED(CO_ORDER_POP)
# undef xmacro

			/* "pop %%rbp\n\t" */
			"pop %%rbp\n\t"

			"ret\n\t"

			: [our_frame] "=m"(from->co_frame)

			: [frame] "r"(to->co_frame),
			  [stack] "r"(to->co_stack)/*,*/
			  /* [from] "g"(from), */
			  /* [arg] "g"(arg) */

			:
#define xmacro(name) #name,
			  CO_CALLEE_SAVED(CO_ORDER_POP)
#undef xmacro
			  "rax", "r11"
			);
#endif
}

/* vim: set ft=c: */
